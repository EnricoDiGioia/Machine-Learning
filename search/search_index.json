{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#template-de-entrega","title":"Template de Entrega","text":"Edi\u00e7\u00e3o <p>2025.1</p>"},{"location":"#grupokit-x","title":"Grupo/Kit X","text":"<ol> <li>Arthur Borba</li> <li>Arthur Napoles</li> <li>Enrico Comasseto Di Gioia</li> <li>Enzo godoy</li> <li>Rafael Lucena</li> <li>Ycaro Campovilla</li> <li>Grupo K<ul> <li>Jo\u00e3o da Silva</li> <li>Pedro de Souza</li> </ul> </li> </ol> <p>Instru\u00e7\u00f5es</p> <p>Voc\u00eas devem utilizar este template como um bloco de notas para registrar o que foi feito e o que falta fazer. Voc\u00eas devem adicionar as informa\u00e7\u00f5es necess\u00e1rias. O template deve ser editado e atualizado a cada entrega, registrando assim a data de entrega e o que foi feito at\u00e9 o momento via Git.</p>"},{"location":"#entregas","title":"Entregas","text":"<ul> <li> Roteiro 1 - Data 23/02/2025</li> <li> Roteiro 2</li> <li> Roteiro 3</li> <li> Roteiro 4</li> <li> Projeto</li> </ul>"},{"location":"#diagramas","title":"Diagramas","text":"<p>Use o Mermaid para criar os diagramas de documenta\u00e7\u00e3o.</p> <p>Mermaid Live Editor</p> <pre><code>flowchart TD\n    Deployment:::orange --&gt;|defines| ReplicaSet\n    ReplicaSet --&gt;|manages| pod((Pod))\n    pod:::red --&gt;|runs| Container\n    Deployment --&gt;|scales| pod\n    Deployment --&gt;|updates| pod\n\n    Service:::orange --&gt;|exposes| pod\n\n    subgraph  \n        ConfigMap:::orange\n        Secret:::orange\n    end\n\n    ConfigMap --&gt; Deployment\n    Secret --&gt; Deployment\n    classDef red fill:#f55\n    classDef orange fill:#ffa500</code></pre>"},{"location":"#codigos","title":"C\u00f3digos","text":"De um arquivo remotoAnota\u00e7\u00f5es no c\u00f3digo main.yaml<pre><code>name: ci\non:\n  - push\n  - pull_request\n\n# Environment\nenv:\n  CI: true\n  PYTHON_VERSION: 3.12\n\n# Jobs to run\njobs:\n\n  # Build and deploy documentation site\n  deploy:\n    if: github.event_name != 'pull_request' &amp;&amp; github.ref == 'refs/heads/main'\n    runs-on: ubuntu-latest\n    steps:\n\n      # Checkout source form GitHub\n      - uses: actions/checkout@v4\n\n      # Install Python runtime and dependencies\n      - uses: actions/setup-python@v4\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n\n      # pip\n      - run: |\n          pip install -r requirements.txt\n\n      # deploy\n      - run: |\n          mkdocs gh-deploy --force\n</code></pre> compose.yaml<pre><code>name: app\n\n    db:\n        image: postgres:17\n        environment:\n            POSTGRES_DB: ${POSTGRES_DB:-projeto} # (1)!\n            POSTGRES_USER: ${POSTGRES_USER:-projeto}\n            POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-projeto}\n        ports:\n            - 5432:5432 #(2)!\n</code></pre> <ol> <li> <p>Caso a vari\u00e1vel de ambiente <code>POSTGRES_DB</code> n\u00e3o exista ou seja nula - n\u00e3o seja definida no arquivo <code>.env</code> - o valor padr\u00e3o ser\u00e1 <code>projeto</code>. Vide documenta\u00e7\u00e3o.</p> </li> <li> <p>Aqui \u00e9 feito um t\u00fanel da porta 5432 do container do banco de dados para a porta 5432 do host (no caso localhost). Em um ambiente de produ\u00e7\u00e3o, essa porta n\u00e3o deve ser exposta, pois ningu\u00e9m de fora do compose deveria acessar o banco de dados diretamente.</p> </li> </ol>"},{"location":"#exemplo-de-video","title":"Exemplo de v\u00eddeo","text":"<p>Lorem ipsum dolor sit amet</p>"},{"location":"#referencias","title":"Refer\u00eancias","text":"<p>Material for MkDocs</p>"},{"location":"DecisionTree/main/","title":"Decision Tree","text":""},{"location":"DecisionTree/main/#1-exploracao-dos-dados-20","title":"1    Explora\u00e7\u00e3o dos Dados 20","text":"model year price transmission mileage fuelType tax mpg engineSize A4 2012 9990 Manual 49500 Diesel 30 62.8 2 A3 2019 22382 Manual 4352 Diesel 145 51.4 1.6 A6 2019 28990 Semi-Auto 7000 Diesel 150 47.9 2 A3 2020 30777 Semi-Auto 3925 Petrol 145 44.1 1.5 A4 2016 14950 Manual 22000 Petrol 145 51.4 1.4 Q2 2019 24365 Manual 3578 Diesel 145 47.9 1.6 Q7 2016 30495 Semi-Auto 22639 Diesel 165 48.7 3 A7 2017 29900 Semi-Auto 14468 Diesel 145 52.3 3 A4 2016 15256 Manual 25214 Diesel 0 74.3 2 Q2 2020 24950 Semi-Auto 789 Diesel 145 47.9 1.6"},{"location":"DecisionTree/main/#2-pre-processamento-10","title":"2    Pr\u00e9-processamento 10","text":"<p>Para iniciar o processo de an\u00e1lise, foi realizado o carregamento do dataset de carros Audi, dispon\u00edvel em formato CSV. Em seguida, foi feita uma amostragem aleat\u00f3ria de 10 registros para facilitar a visualiza\u00e7\u00e3o e manipula\u00e7\u00e3o inicial dos dados.</p> <p>Na etapa de pr\u00e9-processamento, valores ausentes nas colunas num\u00e9ricas (tax, mpg e price) foram preenchidos com a mediana de cada coluna, garantindo que n\u00e3o houvesse dados faltantes que pudessem prejudicar as an\u00e1lises subsequentes. Ap\u00f3s o tratamento dos dados, foram selecionadas as principais vari\u00e1veis de interesse: model, year, price, transmission, mileage, fuelType, tax, mpg e engineSize.</p> <p>A visualiza\u00e7\u00e3o das primeiras linhas do dataset permitiu verificar a estrutura dos dados, identificar poss\u00edveis inconsist\u00eancias e compreender melhor as vari\u00e1veis dispon\u00edveis para a constru\u00e7\u00e3o dos modelos de machine learning.</p> <p>2.1 Data cleaning</p> model year price transmission mileage fuelType tax mpg engineSize A4 2012 9990 Manual 49500 Diesel 30 62.8 2 A3 2019 22382 Manual 4352 Diesel 145 51.4 1.6 A6 2019 28990 Semi-Auto 7000 Diesel 150 47.9 2 A3 2020 30777 Semi-Auto 3925 Petrol 145 44.1 1.5 A4 2016 14950 Manual 22000 Petrol 145 51.4 1.4 Q2 2019 24365 Manual 3578 Diesel 145 47.9 1.6 Q7 2016 30495 Semi-Auto 22639 Diesel 165 48.7 3 A7 2017 29900 Semi-Auto 14468 Diesel 145 52.3 3 A4 2016 15256 Manual 25214 Diesel 0 74.3 2 Q2 2020 24950 Semi-Auto 789 Diesel 145 47.9 1.6 <p>2.2 Data Encoding Categorical variables</p> model year price transmission mileage fuelType tax mpg engineSize A4 2012 9990 0 49500 0 30 62.8 2 A3 2019 22382 0 4352 0 145 51.4 1.6 A6 2019 28990 1 7000 0 150 47.9 2 A3 2020 30777 1 3925 1 145 44.1 1.5 A4 2016 14950 0 22000 1 145 51.4 1.4 Q2 2019 24365 0 3578 0 145 47.9 1.6 Q7 2016 30495 1 22639 0 165 48.7 3 A7 2017 29900 1 14468 0 145 52.3 3 A4 2016 15256 0 25214 0 0 74.3 2 Q2 2020 24950 1 789 0 145 47.9 1.6 <p>3   Divis\u00e3o dos Dados 20</p> <p>4   Treinamento do Modelo 10</p>"},{"location":"DecisionTree/main/#teste-com-80-dos-dados-para-treino","title":"Teste com 80% dos dados para treino","text":"<p>Ap\u00f3s a etapa de explora\u00e7\u00e3o e pr\u00e9-processamento dos dados, foi realizada a divis\u00e3o do dataset em conjuntos de treino e teste. Essa separa\u00e7\u00e3o \u00e9 fundamental para avaliar o desempenho do modelo de machine learning de forma imparcial, garantindo que o algoritmo seja treinado em uma parte dos dados e validado em outra, nunca vista durante o treinamento.</p> <p>Utilizou-se a fun\u00e7\u00e3o train_test_split da biblioteca scikit-learn, que permite dividir os dados de forma aleat\u00f3ria, mantendo a propor\u00e7\u00e3o definida entre treino e teste (por exemplo, 80% para treino e 20% para teste). Dessa forma, \u00e9 poss\u00edvel medir a capacidade de generaliza\u00e7\u00e3o do modelo e evitar problemas como overfitting.</p> CodeDados <pre><code>import matplotlib.pyplot as plt\nimport kagglehub\nimport pandas as pd\nfrom kagglehub import KaggleDatasetAdapter\nfrom io import StringIO\nfrom sklearn import tree\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.metrics import accuracy_score\n\n\nplt.figure(figsize=(12, 10))\n\n# Preprocess the data\ndef preprocess(df):\n    # Fill missing values\n    df['tax'].fillna(df['tax'].median(), inplace=True)\n    df['mpg'].fillna(df['mpg'].median(), inplace=True)\n    df['price'].fillna(df['price'].median(), inplace=True)\n\n    # Convert categorical variables\n    label_encoder = LabelEncoder()\n    df['transmission'] = label_encoder.fit_transform(df['transmission'])\n    df['fuelType'] = label_encoder.fit_transform(df['fuelType'])\n\n    # Select features\n    features = ['model', 'year', 'price', 'transmission', 'mileage', 'fuelType', 'tax', 'mpg', 'engineSize']\n    return df[features]\n\n\n# Load the Audi dataset\ndf = pd.read_csv('https://raw.githubusercontent.com/EnricoDiGioia/Machine-Learning/refs/heads/main/data/audi.csv')\n\n# Preprocessing\ndf = preprocess(df)\n\n# Display the first few rows of the dataset\n#print(df.sample(n=10, random_state=42).to_markdown(index=False))\n\n# Carregar o conjunto de dados\nx = df[['price', 'tax', 'mpg', 'engineSize', 'mileage', 'year']]\ny = df['fuelType']\n\n# Dividir os dados em conjuntos de treinamento e teste\nx_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)\n\n# Criar e treinar o modelo de \u00e1rvore de decis\u00e3o\nclassifier = tree.DecisionTreeClassifier()\nclassifier.fit(x_train, y_train)\n\n# Avaliar o modelo\naccuracy = classifier.score(x_test, y_test)\nprint(f\"Accuracy: {accuracy:.2f}\")\ntree.plot_tree(classifier)\n\n\n# Para imprimir na p\u00e1gina HTML\nbuffer = StringIO()\nplt.savefig(buffer, format=\"svg\")\nprint(buffer.getvalue())\n</code></pre> <p>Accuracy: 0.99  2025-10-24T13:30:14.826391 image/svg+xml Matplotlib v3.10.7, https://matplotlib.org/ </p> <p>O teste com 80% atingiu 99% de acur\u00e1cia, ou seja, overfitting.</p>"},{"location":"DecisionTree/main/#teste-com-70-dos-dados-para-treino","title":"Teste com 70% dos dados para treino","text":"<p>Accuracy: 0.99  2025-10-24T13:30:19.033679 image/svg+xml Matplotlib v3.10.7, https://matplotlib.org/ </p> <p>O teste com 70% atingiu 99% de acur\u00e1cia, ou seja, overfitting.</p>"},{"location":"DecisionTree/main/#teste-com-60-dos-dados-para-treino","title":"Teste com 60% dos dados para treino","text":"<p>Accuracy: 0.98  2025-10-24T13:30:23.016435 image/svg+xml Matplotlib v3.10.7, https://matplotlib.org/ </p> <p>O teste com 60% atingiu 98% de acur\u00e1cia, ou seja, overfitting.</p>"},{"location":"DecisionTree/main/#teste-com-50-dos-dados-para-treino","title":"Teste com 50% dos dados para treino","text":"<p>Accuracy: 0.98  2025-10-24T13:30:26.578489 image/svg+xml Matplotlib v3.10.7, https://matplotlib.org/ </p> <p>O teste com 50% atingiu 98% de acur\u00e1cia, ou seja, overfitting.</p>"},{"location":"DecisionTree/main/#5-avaliacao-do-modelo-20","title":"5    Avalia\u00e7\u00e3o do Modelo 20","text":"<p>Com os testes realizados, \u00e9 poss\u00edvel ver que com esta base de dados \u00e9 imposs\u00edvel fazer um modelo confi\u00e1vel com esta t\u00e9cnica. Talvez, usando alguma outra t\u00e9cnica ou com mais dados, seria poss\u00edvel.</p>"},{"location":"DecisionTree/main/#6-relatorio-final","title":"6    Relat\u00f3rio Final","text":"<p>Neste projeto, foi realizada a an\u00e1lise e modelagem de dados utilizando a t\u00e9cnica de \u00e1rvore de decis\u00e3o. O processo envolveu a explora\u00e7\u00e3o dos dados, pr\u00e9-processamento, codifica\u00e7\u00e3o de vari\u00e1veis categ\u00f3ricas, divis\u00e3o dos dados em conjuntos de treino e teste, e avalia\u00e7\u00e3o do desempenho do modelo.</p> <p>Os testes realizados com diferentes propor\u00e7\u00f5es de dados para treino (80%, 70%, 60% e 50%) mostraram que o modelo atingiu alta acur\u00e1cia (99%), indicando ocorr\u00eancia de overfitting. Isso significa que o modelo est\u00e1 ajustado demais aos dados de treino e pode n\u00e3o generalizar bem para novos dados.</p> <p>A partir dos resultados, conclui-se que, com esta base de dados e t\u00e9cnica utilizada, n\u00e3o \u00e9 poss\u00edvel construir um modelo confi\u00e1vel. Recomenda-se testar outras t\u00e9cnicas de machine learning ou utilizar uma base de dados maior e mais variada para obter resultados mais robustos.</p>"},{"location":"K-Means/main/","title":"K-Means","text":""},{"location":"K-Means/main/#1-carregamento-dos-dados","title":"1. Carregamento dos Dados","text":"<p>Os dados utilizados s\u00e3o provenientes de um arquivo CSV hospedado online, contendo informa\u00e7\u00f5es sobre carros, como quilometragem (<code>mileage</code>), pre\u00e7o (<code>price</code>) e tipo de transmiss\u00e3o (<code>transmission</code>). O carregamento \u00e9 feito com pandas:</p> <pre><code>import pandas as pd\nurl = \"https://raw.githubusercontent.com/EnricoDiGioia/Machine-Learning/refs/heads/main/data/audi.csv\"\ndf = pd.read_csv(url)\n</code></pre>"},{"location":"K-Means/main/#2-selecao-de-variaveis-para-clustering","title":"2. Sele\u00e7\u00e3o de Vari\u00e1veis para Clustering","text":"<p>Para o agrupamento, s\u00e3o escolhidas duas vari\u00e1veis num\u00e9ricas: <code>mileage</code> e <code>price</code>. Elas s\u00e3o extra\u00eddas do DataFrame para formar a matriz de entrada do K-Means:</p> <pre><code>X = df[[\"mileage\", \"price\"]].values\n</code></pre>"},{"location":"K-Means/main/#3-execucao-do-k-means","title":"3. Execu\u00e7\u00e3o do K-Means","text":"<p>O algoritmo K-Means \u00e9 aplicado para dividir os dados em grupos (clusters) com base na similaridade dessas vari\u00e1veis.</p> <pre><code>from sklearn.cluster import KMeans\nkmeans = KMeans(n_clusters=3, init='k-means++', max_iter=100, random_state=42)\nlabels = kmeans.fit_predict(X)\ndf['cluster'] = labels\n</code></pre>"},{"location":"K-Means/main/#4-visualizacao-dos-resultados","title":"4. Visualiza\u00e7\u00e3o dos Resultados","text":"<p>Os clusters s\u00e3o visualizados em um gr\u00e1fico de dispers\u00e3o, onde cada cor representa um cluster. A legenda mostra, para cada cluster, a distribui\u00e7\u00e3o dos tipos de transmiss\u00e3o mais comuns:</p> <pre><code>import matplotlib.pyplot as plt\ncmap = plt.get_cmap('viridis')\ncolors = [cmap(i / (kmeans.n_clusters - 1)) for i in range(kmeans.n_clusters)]\nlegend_labels = []\nfor cluster in range(kmeans.n_clusters):\n    cluster_data = df[df['cluster'] == cluster]\n    trans_counts = cluster_data['transmission'].value_counts(normalize=True).head(2)\n    parts = [f\"{t} {p*100:.0f}%\" for t, p in trans_counts.items()]\n    legend_labels.append(f\"Cluster {cluster}: \" + \" | \".join(parts))\n    plt.scatter(cluster_data['mileage'], cluster_data['price'], color=colors[cluster], s=50)\nfor i, txt in enumerate(legend_labels):\n    plt.scatter([], [], color=colors[i], label=txt)\nplt.scatter(kmeans.cluster_centers_[:,0], kmeans.cluster_centers_[:,1], c='red', marker='*', s=200, label='Centroids')\nplt.legend()\nplt.title('K-Means Clustering Results')\nplt.xlabel('Mileage')\nplt.ylabel('Price')\n</code></pre>"},{"location":"K-Means/main/#5-interpretacao-dos-clusters","title":"5. Interpreta\u00e7\u00e3o dos Clusters","text":"<p>Ap\u00f3s o agrupamento, \u00e9 poss\u00edvel analisar a rela\u00e7\u00e3o entre os clusters e o tipo de transmiss\u00e3o. O K-Means n\u00e3o utiliza <code>transmission</code> para formar os grupos, mas a distribui\u00e7\u00e3o desse atributo em cada cluster pode ser observada na legenda e em tabelas cruzadas:</p> <pre><code>print(pd.crosstab(df['cluster'], df['transmission']))\n</code></pre>"},{"location":"K-Means/main/#6-limitacoes-e-consideracoes","title":"6. Limita\u00e7\u00f5es e Considera\u00e7\u00f5es","text":"<ul> <li>O K-Means s\u00f3 considera as vari\u00e1veis num\u00e9ricas escolhidas.</li> <li>Se um tipo de transmiss\u00e3o for dominante, pode aparecer repetido na legenda de v\u00e1rios clusters.</li> <li>Para incluir vari\u00e1veis categ\u00f3ricas no agrupamento, \u00e9 necess\u00e1rio codific\u00e1-las (one-hot encoding) ou usar algoritmos espec\u00edficos para dados mistos (ex.: k-prototypes).</li> </ul>"},{"location":"K-Means/main/#7-exemplos-de-codigo","title":"7. Exemplos de C\u00f3digo","text":"<p>Os c\u00f3digos trazem exemplos completos do processo descrito acima:</p> 2025-10-24T13:30:29.852742 image/svg+xml Matplotlib v3.10.7, https://matplotlib.org/ <p>O serguinte arquivo implementa o processo de agrupamento K-Means utilizando os dados de carros, considerando as vari\u00e1veis <code>mileage</code> (quilometragem) e <code>price</code> (pre\u00e7o). Ap\u00f3s o agrupamento, o script analisa a distribui\u00e7\u00e3o dos tipos de transmiss\u00e3o (<code>transmission</code>) dentro de cada cluster, exibindo essa informa\u00e7\u00e3o na legenda do gr\u00e1fico. Isso permite visualizar n\u00e3o apenas os grupos formados por caracter\u00edsticas num\u00e9ricas, mas tamb\u00e9m como o atributo categ\u00f3rico transmiss\u00e3o est\u00e1 distribu\u00eddo entre os clusters, facilitando a interpreta\u00e7\u00e3o dos resultados.</p> 2025-10-24T13:30:30.302866 image/svg+xml Matplotlib v3.10.7, https://matplotlib.org/"},{"location":"KNN/main/","title":"KNN","text":""},{"location":"KNN/main/#1-exploracao-dos-dados-20","title":"1    Explora\u00e7\u00e3o dos Dados 20","text":"<p>Nessa fase, buscamos compreender a estrutura, as caracter\u00edsticas e poss\u00edveis inconsist\u00eancias do conjunto de dados. Inicialmente, realizamos a leitura do dataset e a visualiza\u00e7\u00e3o das primeiras linhas para identificar o tipo de vari\u00e1veis presentes, como colunas num\u00e9ricas e categ\u00f3ricas, al\u00e9m de verificar a exist\u00eancia de valores ausentes ou discrepantes. Essa an\u00e1lise inicial permite entender melhor o comportamento dos dados, orientar a sele\u00e7\u00e3o de features relevantes e definir os pr\u00f3ximos passos para a prepara\u00e7\u00e3o e modelagem dos dados.</p> model year price transmission mileage fuelType tax mpg engineSize A4 2012 9990 Manual 49500 Diesel 30 62.8 2 A3 2019 22382 Manual 4352 Diesel 145 51.4 1.6 A6 2019 28990 Semi-Auto 7000 Diesel 150 47.9 2 A3 2020 30777 Semi-Auto 3925 Petrol 145 44.1 1.5 A4 2016 14950 Manual 22000 Petrol 145 51.4 1.4 Q2 2019 24365 Manual 3578 Diesel 145 47.9 1.6 Q7 2016 30495 Semi-Auto 22639 Diesel 165 48.7 3 A7 2017 29900 Semi-Auto 14468 Diesel 145 52.3 3 A4 2016 15256 Manual 25214 Diesel 0 74.3 2 Q2 2020 24950 Semi-Auto 789 Diesel 145 47.9 1.6"},{"location":"KNN/main/#2-pre-processamento-10","title":"2    Pr\u00e9-processamento 10","text":"<p>Para iniciar o processo de an\u00e1lise, foi realizado o carregamento do dataset de carros Audi, dispon\u00edvel em formato CSV. Em seguida, foi feita uma amostragem aleat\u00f3ria de 10 registros para facilitar a visualiza\u00e7\u00e3o e manipula\u00e7\u00e3o inicial dos dados.</p> <p>Na etapa de pr\u00e9-processamento, valores ausentes nas colunas num\u00e9ricas (tax, mpg e price) foram preenchidos com a mediana de cada coluna, garantindo que n\u00e3o houvesse dados faltantes que pudessem prejudicar as an\u00e1lises subsequentes. Ap\u00f3s o tratamento dos dados, foram selecionadas as principais vari\u00e1veis de interesse: model, year, price, transmission, mileage, fuelType, tax, mpg e engineSize.</p> <p>A visualiza\u00e7\u00e3o das primeiras linhas do dataset permitiu verificar a estrutura dos dados, identificar poss\u00edveis inconsist\u00eancias e compreender melhor as vari\u00e1veis dispon\u00edveis para a constru\u00e7\u00e3o dos modelos de machine learning.</p> <p>2.1 Data cleaning</p> model year price transmission mileage fuelType tax mpg engineSize A4 2012 9990 Manual 49500 Diesel 30 62.8 2 A3 2019 22382 Manual 4352 Diesel 145 51.4 1.6 A6 2019 28990 Semi-Auto 7000 Diesel 150 47.9 2 A3 2020 30777 Semi-Auto 3925 Petrol 145 44.1 1.5 A4 2016 14950 Manual 22000 Petrol 145 51.4 1.4 Q2 2019 24365 Manual 3578 Diesel 145 47.9 1.6 Q7 2016 30495 Semi-Auto 22639 Diesel 165 48.7 3 A7 2017 29900 Semi-Auto 14468 Diesel 145 52.3 3 A4 2016 15256 Manual 25214 Diesel 0 74.3 2 Q2 2020 24950 Semi-Auto 789 Diesel 145 47.9 1.6"},{"location":"KNN/main/#3-treinamento-do-modelo","title":"3 Treinamento do modelo","text":"<p>Com os dados devidamente preparados e divididos, foi realizado o treinamento do modelo KNN (K-Nearest Neighbors). O modelo foi ajustado utilizando o conjunto de treino, onde o algoritmo aprende a identificar padr\u00f5es e rela\u00e7\u00f5es entre as vari\u00e1veis de entrada (features) e o alvo (r\u00f3tulo).</p> <p>Durante o treinamento, o KNN armazena os exemplos do conjunto de treino e, ao receber uma nova amostra, classifica-a com base nos vizinhos mais pr\u00f3ximos, de acordo com a m\u00e9trica de dist\u00e2ncia escolhida. O par\u00e2metro k define o n\u00famero de vizinhos considerados para a decis\u00e3o. Esse processo \u00e9 fundamental para que o modelo possa realizar previs\u00f5es precisas em novos dados.</p> Code <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom io import StringIO\nfrom sklearn.calibration import LabelEncoder\nfrom sklearn.datasets import make_classification\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.metrics import accuracy_score\nimport pandas as pd\nimport seaborn as sns\n\nplt.figure(figsize=(10, 6))\n\n# Limpar e preparar os dados\ndef preprocess(df):\n    # Fill missing values\n    df['tax'].fillna(df['tax'].median(), inplace=True)\n    df['mpg'].fillna(df['mpg'].median(), inplace=True)\n    df['price'].fillna(df['price'].median(), inplace=True)\n\n    # Convert categorical variables\n    label_encoder = LabelEncoder()\n    df['transmission'] = label_encoder.fit_transform(df['transmission'])\n    df['fuelType'] = label_encoder.fit_transform(df['fuelType'])\n    return df\n\n# Generate synthetic dataset\ndf = pd.read_csv('https://raw.githubusercontent.com/EnricoDiGioia/Machine-Learning/refs/heads/main/data/audi.csv')\ndf = preprocess(df)\nX = df[['price', 'tax', 'mpg', 'engineSize', 'mileage', 'year']]\ny = df['fuelType']\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# Train KNN model\nknn = KNeighborsClassifier(n_neighbors=3)\nknn.fit(X_train, y_train)\npredictions = knn.predict(X_test)\nprint(f\"Accuracy: {accuracy_score(y_test, predictions):.2f}\")\n\n\ndf_plot = pd.DataFrame()\ndf_plot['price'] = (X['price']-X['price'].min())/(X['price'].max()-X['price'].min())\ndf_plot['tax'] = (X['tax']-X['tax'].min())/(X['tax'].max()-X['tax'].min())\ndf_plot['fuelType'] = y\nsns.scatterplot(data=df_plot, x='price', y='tax', hue='fuelType')\n\n\n#Ver se \u00e9 necessario dps\n\n# Visualize decision boundary\n#h = 0.02  # Step size in mesh\n#x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1\n#y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1\n#xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h))\n#\n#Z = knn.predict(np.c_[xx.ravel(), yy.ravel()])\n#Z = Z.reshape(xx.shape)\n#\n#plt.contourf(xx, yy, Z, cmap=plt.cm.RdYlBu, alpha=0.3)\n#sns.scatterplot(x=X[:, 0], y=X[:, 1], hue=y, style=y, palette=\"deep\", s=100)\n#plt.xlabel(\"Feature 1\")\n#plt.ylabel(\"Feature 2\")\n#plt.title(\"KNN Decision Boundary (k=3)\")\n#\n## Display the plot\nbuffer = StringIO()\nplt.savefig(buffer, format=\"svg\", transparent=True)\nprint(buffer.getvalue())\n</code></pre>"},{"location":"KNN/main/#4-avaliacao-do-modelo-20","title":"4 Avalia\u00e7\u00e3o do Modelo    20","text":"<p>Ap\u00f3s o treinamento do modelo KNN, a avalia\u00e7\u00e3o de desempenho foi realizada utilizando o conjunto de teste separado anteriormente. Para isso, o modelo fez previs\u00f5es sobre os dados de teste e a acur\u00e1cia foi calculada por meio da fun\u00e7\u00e3o accuracy_score da biblioteca scikit-learn.</p> <p>A acur\u00e1cia representa a propor\u00e7\u00e3o de previs\u00f5es corretas em rela\u00e7\u00e3o ao total de exemplos avaliados, sendo uma m\u00e9trica simples e direta para problemas de classifica\u00e7\u00e3o. Esse processo permite verificar se o modelo est\u00e1 generalizando bem para dados que n\u00e3o foram vistos durante o treinamento, fornecendo uma estimativa confi\u00e1vel de seu desempenho em situa\u00e7\u00f5es reais.</p> <p>Accuracy: 0.63  2025-10-24T13:30:31.149093 image/svg+xml Matplotlib v3.10.7, https://matplotlib.org/ </p>"},{"location":"KNN/main/#5-relatorio-final","title":"5    Relat\u00f3rio Final","text":"<p>O processo iniciou-se com a explora\u00e7\u00e3o dos dados, onde foram identificadas as principais caracter\u00edsticas do conjunto e tratados eventuais valores ausentes. Em seguida, os dados foram divididos em conjuntos de treino e teste, garantindo uma avalia\u00e7\u00e3o imparcial do modelo.</p> <p>O treinamento do modelo KNN foi realizado com o conjunto de treino, utilizando as vari\u00e1veis mais relevantes para a tarefa de classifica\u00e7\u00e3o. Ap\u00f3s o ajuste, o modelo foi avaliado com o conjunto de teste, sendo a acur\u00e1cia utilizada como principal m\u00e9trica de desempenho. O resultado obtido demonstrou a capacidade do modelo em generalizar para novos dados, validando a abordagem adotada.</p> <p>Por fim, a visualiza\u00e7\u00e3o da fronteira de decis\u00e3o permitiu compreender como o modelo separa as diferentes classes no espa\u00e7o das features escolhidas. O experimento evidenciou a import\u00e2ncia das etapas de prepara\u00e7\u00e3o dos dados, escolha adequada das vari\u00e1veis e valida\u00e7\u00e3o do modelo para o sucesso em projetos de machine learning.</p>"},{"location":"Metricas/main/","title":"M\u00e9tricas","text":""},{"location":"Metricas/main/#metricas-de-avaliacao-arvore-de-decisao","title":"M\u00e9tricas de Avalia\u00e7\u00e3o - \u00c1rvore de Decis\u00e3o","text":""},{"location":"Metricas/main/#metricas-utilizadas","title":"M\u00e9tricas Utilizadas","text":"<p>Accuracy: Percentual de acertos totais do modelo Precision (Weighted): Propor\u00e7\u00e3o de predi\u00e7\u00f5es positivas corretas, ponderada por classe F1-Score (Weighted): M\u00e9dia harm\u00f4nica entre Precision e Recall, balanceada para multiclasse Matriz de Confus\u00e3o: Tabela que mostra predi\u00e7\u00f5es corretas e incorretas por classe</p>"},{"location":"Metricas/main/#por-que-essas-metricas","title":"Por que essas m\u00e9tricas?","text":"<ul> <li>Accuracy: Baseline fundamental para compara\u00e7\u00e3o</li> <li>Precision: Evita falsos positivos (ex: classificar Petrol como Hybrid)</li> <li>F1-Score: Balanceia performance em dataset com classes desbalanceadas (Hybrid \u00e9 menos comum)</li> <li>Matriz de Confus\u00e3o: Permite an\u00e1lise detalhada de erros por classe espec\u00edfica</li> </ul> <p>Weighted Average: Pondera cada classe pelo n\u00famero de amostras, adequado para classifica\u00e7\u00e3o multiclasse (Diesel, Petrol, Hybrid).</p>"},{"location":"Metricas/main/#tabela-resumo-das-metricas","title":"Tabela Resumo das M\u00e9tricas","text":"2025-10-24T13:30:32.123027 image/svg+xml Matplotlib v3.10.7, https://matplotlib.org/"},{"location":"Metricas/main/#arvore-de-decisao-com-metricas","title":"\u00c1rvore de Decis\u00e3o com M\u00e9tricas","text":"<p>Accuracy: 0.9810 Precision: 0.9811 F1-Score: 0.9810  2025-10-24T13:30:35.109540 image/svg+xml Matplotlib v3.10.7, https://matplotlib.org/ </p>"},{"location":"Metricas/main/#matriz-de-confusao-detalhada","title":"Matriz de Confus\u00e3o Detalhada","text":"<p>Accuracy: 0.9822 Precision: 0.9823 F1-Score: 0.9822  Matriz de Confus\u00e3o: Linhas: Condi\u00e7\u00e3o Real (Valores Verdadeiros) Colunas: Condi\u00e7\u00e3o Predita (Valores Preditos pelo Modelo) Diagonal: Verdadeiros Positivos | Fora da Diagonal: Falsos Positivos/Negativos              Diesel   Hybrid   Petrol     Diesel     2217       2      37     Hybrid        0       8       0     Petrol       37       0    1967  2025-10-24T13:30:38.837500 image/svg+xml Matplotlib v3.10.7, https://matplotlib.org/ </p>"},{"location":"RandomFlorest/main/","title":"Random Florest","text":""},{"location":"RandomFlorest/main/#random-forest-para-classificacao-de-modelos","title":"Random Forest para Classifica\u00e7\u00e3o de Modelos","text":""},{"location":"RandomFlorest/main/#sobre-o-script","title":"Sobre o Script","text":"<p>O script abaixo utiliza o dataset <code>audi.csv</code>, que cont\u00e9m informa\u00e7\u00f5es sobre carros da marca Audi, para prever o modelo do carro (<code>model</code>) a partir de caracter\u00edsticas como ano, pre\u00e7o, transmiss\u00e3o, quilometragem, tipo de combust\u00edvel, imposto, consumo (mpg) e tamanho do motor.</p>"},{"location":"RandomFlorest/main/#passos-principais","title":"Passos principais:","text":"<ol> <li>Carregamento dos dados: O dataset \u00e9 lido diretamente de uma URL.</li> <li>Pr\u00e9-processamento:<ul> <li>Remo\u00e7\u00e3o de espa\u00e7os em branco dos nomes das colunas.</li> <li>Separa\u00e7\u00e3o das vari\u00e1veis preditoras (X) e do alvo (y).</li> <li>Codifica\u00e7\u00e3o das vari\u00e1veis categ\u00f3ricas e do alvo usando <code>LabelEncoder</code>.</li> </ul> </li> <li>Divis\u00e3o dos dados: Os dados s\u00e3o divididos em treino e teste (80%/20%).</li> <li>Treinamento: Um modelo <code>RandomForestClassifier</code> \u00e9 treinado para prever o modelo do carro.</li> <li>Avalia\u00e7\u00e3o: O script imprime a acur\u00e1cia do modelo e a import\u00e2ncia de cada feature para a classifica\u00e7\u00e3o.</li> </ol>"},{"location":"RandomFlorest/main/#codigo","title":"C\u00f3digo","text":"<p>Accuracy: 0.5524835988753515 Feature Importances: [0.04144809 0.19694073 0.01491391 0.04202797 0.09726528 0.11844603  0.20736773 0.28159025] </p>"},{"location":"RandomFlorest/main/#interpretacao-da-saida","title":"Interpreta\u00e7\u00e3o da Sa\u00edda","text":"<p>Ao executar o script, voc\u00ea ver\u00e1 uma sa\u00edda semelhante a:</p> <pre><code>Accuracy: 0.5524835988753515\nFeature Importances: [0.04144809 0.19694073 0.01491391 0.04202797 0.09726528 0.11844603 0.20736773 0.28159025]\n</code></pre>"},{"location":"RandomFlorest/main/#o-que-significa-cada-parte","title":"O que significa cada parte?","text":"<ul> <li> <p>Accuracy:</p> <ul> <li>Representa a propor\u00e7\u00e3o de acertos do modelo no conjunto de teste. No exemplo acima, o modelo acertou cerca de 55% das previs\u00f5es.</li> <li>Em problemas de classifica\u00e7\u00e3o com m\u00faltiplas classes (v\u00e1rios modelos Audi), valores em torno de 0.5 podem indicar que o modelo est\u00e1 aprendendo padr\u00f5es, mas ainda h\u00e1 espa\u00e7o para melhorias (por exemplo, com mais ajustes ou outros algoritmos).</li> </ul> </li> <li> <p>Feature Importances:</p> <ul> <li>\u00c9 um vetor que mostra a import\u00e2ncia relativa de cada feature (coluna) para a decis\u00e3o do modelo.</li> <li>Quanto maior o valor, mais relevante aquela feature foi para a classifica\u00e7\u00e3o.</li> <li>A ordem dos valores corresponde \u00e0 ordem das colunas em <code>X</code> ap\u00f3s o pr\u00e9-processamento:<ol> <li>year</li> <li>price</li> <li>transmission</li> <li>mileage</li> <li>fuelType</li> <li>tax</li> <li>mpg</li> <li>engineSize</li> </ol> </li> <li>Por exemplo, no resultado acima, <code>engineSize</code> (0.28), <code>mpg</code> (0.20) e <code>price</code> (0.19) foram as vari\u00e1veis mais importantes para prever o modelo do carro.</li> </ul> </li> </ul>"},{"location":"RandomFlorest/main/#resumindo","title":"Resumindo","text":"<p>O modelo Random Forest consegue identificar quais caracter\u00edsticas dos carros Audi mais influenciam na distin\u00e7\u00e3o entre os diferentes modelos, al\u00e9m de fornecer uma m\u00e9trica quantitativa de desempenho (acur\u00e1cia) para avaliar sua performance.</p>"},{"location":"projeto/main/","title":"Projeto","text":"<p>Aqui vai toda a documenta\u00e7\u00e3o do projeto, incluindo o que j\u00e1 foi feito e o que falta fazer.</p>"},{"location":"roteiro1/main/","title":"Roteiro 1","text":""},{"location":"roteiro1/main/#objetivo","title":"Objetivo","text":"<p>Aqui vai o objetivo macro do roteiro. Por que estamos fazendo o que estamos fazendo?</p>"},{"location":"roteiro1/main/#montagem-do-roteiro","title":"Montagem do Roteiro","text":"<p>Os pontos \"tarefas\" s\u00e3o os passos que devem ser seguidos para a realiza\u00e7\u00e3o do roteiro. Eles devem ser claros e objetivos. Com evid\u00eancias claras de que foram realizados.</p>"},{"location":"roteiro1/main/#tarefa-1","title":"Tarefa 1","text":"<p>Instalando o MAAS:</p> sudo snap install maas --channel=3.5/Stable <p></p> <p>Dashboard do MAAS</p> <p>Conforme ilustrado acima, a tela inicial do MAAS apresenta um dashboard com informa\u00e7\u00f5es sobre o estado atual dos servidores gerenciados. O dashboard \u00e9 composto por diversos pain\u00e9is, cada um exibindo informa\u00e7\u00f5es sobre um aspecto espec\u00edfico do ambiente gerenciado. Os pain\u00e9is podem ser configurados e personalizados de acordo com as necessidades do usu\u00e1rio.</p>"},{"location":"roteiro1/main/#tarefa-2","title":"Tarefa 2","text":""},{"location":"roteiro1/main/#app","title":"App","text":""},{"location":"roteiro1/main/#tarefa-1_1","title":"Tarefa 1","text":""},{"location":"roteiro1/main/#tarefa-2_1","title":"Tarefa 2","text":"<p>Exemplo de diagrama</p> <pre><code>architecture-beta\n    group api(cloud)[API]\n\n    service db(database)[Database] in api\n    service disk1(disk)[Storage] in api\n    service disk2(disk)[Storage] in api\n    service server(server)[Server] in api\n\n    db:L -- R:server\n    disk1:T -- B:server\n    disk2:T -- B:db</code></pre> <p>Mermaid</p>"},{"location":"roteiro1/main/#questionario-projeto-ou-plano","title":"Question\u00e1rio, Projeto ou Plano","text":"<p>Esse se\u00e7\u00e3o deve ser preenchida apenas se houver demanda do roteiro.</p>"},{"location":"roteiro1/main/#discussoes","title":"Discuss\u00f5es","text":"<p>Quais as dificuldades encontradas? O que foi mais f\u00e1cil? O que foi mais dif\u00edcil?</p>"},{"location":"roteiro1/main/#conclusao","title":"Conclus\u00e3o","text":"<p>O que foi poss\u00edvel concluir com a realiza\u00e7\u00e3o do roteiro?</p>"},{"location":"roteiro2/main/","title":"Roteiro 2","text":""},{"location":"roteiro2/main/#diagrama-de-classes-do-banco","title":"Diagrama de Classes do Banco","text":"<pre><code>classDiagram\n    class Conta {\n        - String id\n        # double saldo\n        - Cliente cliente\n        + sacar(double valor)\n        + depositar(double valor)\n    }\n    class Cliente {\n        - String id\n        - String nome\n        - List&lt;Conta&gt; contas\n    }\n    class PessoaFisica {\n        - String cpf\n    }\n    class PessoaJuridica {\n        - String cnpj\n    }\n    class ContaCorrente {\n        - double limite\n        + sacar(double valor)\n    }\n    class ContaPoupanca {\n        + sacar(double valor)\n    }\n    Conta *-- Cliente\n    Conta &lt;|-- ContaCorrente\n    Conta &lt;|-- ContaPoupanca\n    Cliente &lt;|-- PessoaFisica\n    Cliente &lt;|-- PessoaJuridica</code></pre>"},{"location":"roteiro2/main/#diagrama-de-sequencia-de-autorizacao","title":"Diagrama de Seq\u00fc\u00eancia de Autoriza\u00e7\u00e3o","text":"<pre><code>sequenceDiagram\n  autonumber\n  actor User\n  User-&gt;&gt;Auth Service: request with token\n  Auth Service-&gt;&gt;Auth Service: decodes the token and extracts claims\n  Auth Service-&gt;&gt;Auth Service: verifies permissions\n  critical allowed\n    Auth Service-&gt;&gt;Secured Resource: authorizes the request\n    Secured Resource-&gt;&gt;User: returns the response\n  option denied\n    Auth Service--&gt;&gt;User: unauthorized message\n  end  </code></pre>"},{"location":"roteiro3/main/","title":"Roteiro 3","text":"<p>Running the code below in Browser (Woooooowwwwww!!!!!!). <sup>1</sup></p> <p> </p> Editor (session: default) Run <pre>import ssl\nimport pandas as pd\n\ndf = pd.DataFrame()\ndf['AAPL'] = pd.Series([1, 2, 3])\ndf['MSFT'] = pd.Series([4, 5, 6])\ndf['GOOGL'] = pd.Series([7, 8, 9])\n\nprint(df)\n</pre> Output Clear <pre></pre> <p></p> <ol> <li> <p>Pyodide \u21a9</p> </li> </ol>"},{"location":"roteiro4/main/","title":"Roteiro 4","text":"<p>Se chegou aqui, \u00e9 porque voc\u00ea est\u00e1 interessado em saber mais. Logo, de brinde, como rodar um c\u00f3digo <code>Python</code> aqui.</p> <p></p> 2025-10-24T13:30:40.198310 image/svg+xml Matplotlib v3.10.7, https://matplotlib.org/ <p>Markdown-exec \u00e9 uma extens\u00e3o do Markdown que permite executar c\u00f3digo Python diretamente no Markdown. Isso \u00e9 \u00fatil para gerar resultados din\u00e2micos ou executar scripts de forma interativa.</p>"}]}